# Task 1 : Introduction

In this room, you will learn about **Session Management**. Reflecting on your interactions with web applications, you'll notice that you don't provide your username and password on every request. Instead, after authentication, the web application provides you with a session. This session keeps track of your state, monitors your actions, and determines whether or not you are authorized to perform specific actions. Proper session management ensures that these steps are secure. Otherwise, a threat actor could compromise your session and hijack it!

## Prerequisites

Before diving into this topic, make sure you are familiar with:

- **Introduction to Web Hacking**
- **Enumeration & Brute Forcing**

## Learning Objectives

By completing this room, you will:

- Understand what **Session Management** is.
- Differentiate between **authentication** and **authorization**, and how they contribute to session management.
- Learn about the two primary **session management methods**.
- Understand the **session management lifecycle**.
- Gain practical experience in exploiting **vulnerable session management implementations**.

# Task 2 : What is Session Management?


Before discussing potential vulnerabilities, we need to understand what **session management** is. As mentioned earlier, you don’t send your username and password with each request. The **HTTP protocol** is inherently stateless, so **sessions** are used to track users throughout their interaction with a web application. **Session management** involves creating, maintaining, and securing these sessions.

## Session Management Lifecycle

The **session management lifecycle** can be broken into four main phases:

### 1. Session Creation

The lifecycle begins when a session is created. While you might think this happens only after you authenticate (e.g., provide your username and password), many web applications create an initial session as soon as you visit the site. This allows the application to track actions even before authentication.

For authenticated sessions:
- After successful authentication, the user receives a **session value** (e.g., a session ID or token).
- This session value is included in subsequent requests to identify and validate the user.
- The secure generation, usage, and storage of these session values are critical to securing the session creation phase.

### 2. Session Tracking

Once the session value is issued, it is sent with every request made by the user. This allows the web application to:
- **Identify the user:** Match the session value to a user on the server-side.
- **Authorize actions:** Determine the user’s permissions.

Flaws in session tracking could allow threat actors to:
- Hijack an active session.
- Impersonate another user.

### 3. Session Expiry

Since the HTTP protocol is stateless, the web application cannot inherently know when a user stops using the service (e.g., closes a tab or browser). To address this, sessions have an associated **lifetime**:
- When the session lifetime expires, the session value is invalidated.
- If the user submits an expired session value, the web application should deny it and require re-authentication.

Failure to implement proper session expiry could allow attackers to reuse old session values and gain unauthorized access.

### 4. Session Termination

Unlike session expiry, **session termination** occurs when a user explicitly logs out. Upon logout:
- The web application should immediately invalidate the session, even if the session’s lifetime has not yet expired.
- Failure to terminate sessions properly could allow attackers to maintain access to an account.

## Next Steps

In this room, we will explore what can go wrong during each phase of the session lifecycle. Our goal is to ensure that **session security** encapsulates the entire lifecycle. But before diving into practical examples, let’s first cover some additional theoretical concepts.


### Which state in the session management lifecycle deals with user's pressing the logout button?
Session Termination
### Which state in the session management lifecycle deals with user's providing their credentials?
Session Creation

### Which state in the session management lifecycle deals with user's actions performed after authentication?
Session Tracking

### Which state in the session management lifecycle deals with user's that forget to log out of the application?
Session Expiry

# Task 3 : Authentication vs Authorisation

### What is the name of the process in the IAAA model that would be responsible for tracking your actions and logging them?
Accountability

### What is the name of the process in the IAAA model that would be responsible for granting you a session value?
Authentication

### What is the name of the process in the IAAA model that would be responsible for verifying that you have the relevant permissions to perform an action?
Authorisation

# Task 4 : Cookies vs Tokens

Before delving into session management security, it’s important to understand the two main approaches to managing sessions: **cookie-based** and **token-based** session management. Each method has its own advantages and challenges.

---

## **Cookie-Based Session Management**

Cookie-based session management is considered the traditional approach. When the web application initiates session tracking, it sends a `Set-Cookie` header in its response. For example:

Set-Cookie: session=12345;


The browser stores this cookie and automatically includes it in subsequent requests to the same domain. Additional attributes can be added to enhance security:

- **Secure**: Ensures the cookie is only sent over HTTPS.
- **HttpOnly**: Prevents access to the cookie via client-side JavaScript.
- **Expire**: Specifies the cookie’s expiration time.
- **SameSite**: Restricts the cookie's use in cross-site requests to mitigate CSRF attacks.

### **Key Characteristics**
- **Automatic Handling**: Browsers automatically send cookies based on the domain and their attributes.
- **Client-Side Limitations**: The browser determines how and when cookies are sent, with limited input from client-side code.
- **Security Features**: Attributes like `Secure`, `HttpOnly`, and `SameSite` offer additional protections.

---

## **Token-Based Session Management**

Token-based session management is a modern alternative, relying on **client-side code** instead of automatic browser handling. After authentication, the web application issues a token, typically stored in the browser’s `LocalStorage` via JavaScript. 

Tokens are sent with each request as part of a custom header, such as:

Authorization: Bearer <token>


JSON Web Tokens (JWTs) are commonly used for this approach. Unlike cookies, token management does not rely on the browser's built-in mechanisms, offering more flexibility.

### **Key Characteristics**
- **Manual Handling**: Tokens must be programmatically included in requests using JavaScript.
- **Custom Security**: Tokens require additional safeguards to prevent unauthorized access or disclosure.
- **Decentralized Applications**: Tokens are particularly well-suited for decentralized or API-driven applications.

---

## **Benefits and Drawbacks**

| Feature                                   | **Cookie-Based Session Management**                                                                                                                                                                                                                               | **Token-Based Session Management**                                                                                                                                                        |
|-------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|
| **Automatic Requests**                    | Cookies are automatically sent by the browser with each request.                                                                                                                                                           | Tokens must be manually included in requests via JavaScript.                                                                                       |
| **Security Enhancements**                 | Attributes like `Secure`, `HttpOnly`, and `SameSite` provide built-in protections.                                                                                                                                          | Tokens have no automatic protections and must be safeguarded programmatically.                                                                     |
| **Vulnerability to Client-Side Attacks**  | Cookies are susceptible to attacks like CSRF, as the browser may unintentionally include them in malicious requests.                                                                                                       | Tokens are less vulnerable to CSRF, as they are not automatically included in requests and cannot be accessed across domains in `LocalStorage`.     |
| **Cross-Domain Flexibility**              | Cookies are domain-specific, making them less suitable for decentralized web applications or APIs.                                                                                                                         | Tokens are portable, can be used across domains, and often include the necessary data for validation.                                               |

---
Understanding the strengths and limitations of cookie-based and token-based session management is crucial for choosing the appropriate method for your application’s architecture and security requirements.

### What cookie attribute can be used to ensure that the cookie is only transmitted via secure HTTPS channels?
secure

### What HTTP header is used in the response to inform the browser that a cookie is being sent?
Set-Cookie

### What HTTP header is often used in requests to indicate the transmission of a JWT?
Authorization: Bearer

# Task 5 : Securing the Session Lifecycle

Session management plays a critical role in securing web applications. However, vulnerabilities can arise at various stages of the **session management lifecycle**. Let’s explore what can go wrong at each phase.

---

## **Session Creation**

### Weak Session Values
- **Problem**: Custom session creation mechanisms can generate weak or predictable session values.
- **Example**: Using Base64 encoding for usernames as session values.
- **Impact**: Threat actors can reverse-engineer session generation, allowing them to guess session values and hijack accounts.

### Controllable Session Values
- **Problem**: Tokens like JWTs may be manipulated if signature verification is not enforced.
- **Impact**: Attackers can forge tokens to gain unauthorized access.

### Session Fixation
- **Problem**: Pre-authentication sessions are not rotated upon authentication.
- **Impact**: Attackers can capture and reuse sessions post-authentication to impersonate users.

### Insecure Session Transmission
- **Problem**: Session data is insecurely transferred between authentication and application servers (e.g., SSO systems).
- **Example**: Oracle's SSO solution had a bug allowing insecure redirects.
- **Impact**: Exposes session material to attackers via manipulated redirects.

---

## **Session Tracking**

### Authorization Bypass
- **Vertical Bypass**: Performing privileged actions (e.g., admin-only tasks) without proper checks.
- **Horizontal Bypass**: Accessing or modifying another user's data due to inadequate ownership checks.
- **Solution**: Use robust validation to ensure the user has the necessary permissions for each action.

### Insufficient Logging
- **Problem**: Missing logs of session actions make incident investigation difficult.
- **Impact**: Inability to trace legitimate or illegitimate actions performed during an attack.
- **Solution**: Log both accepted and rejected actions, including user sessions and associated requests.

---

## **Session Expiry**

### Excessive Session Lifetime
- **Problem**: Sessions remain active for too long, increasing the window for potential misuse.
- **Solution**: Set session expiration times appropriate for the application’s use case:
  - Shorter for sensitive applications (e.g., banking).
  - Longer but location-aware for others (e.g., webmail).

---

## **Session Termination**

### Incomplete Termination
- **Problem**: Sessions are not invalidated on server-side logout.
- **Impact**: Threat actors retain access to active sessions, even if the legitimate user logs out.
- **Solution**:
  - Properly terminate sessions server-side on logout or password reset.
  - Maintain a blocklist for tokens to invalidate compromised sessions.

---

## **Key Takeaways**

1. **Secure Session Creation**: Use robust and unpredictable session values, and rotate them appropriately.
2. **Track Sessions Effectively**: Prevent authorization bypasses and ensure comprehensive logging.
3. **Enforce Expiry**: Align session lifetimes with application security requirements and usage patterns.
4. **Terminate Sessions Properly**: Enable server-side termination of sessions and provide mechanisms for users to invalidate compromised sessions.

By addressing vulnerabilities at each phase of the session lifecycle, web applications can provide a more secure and reliable user experience.

### What phase of the session management lifecycle would be vulnerable if you could predict what the value of a session would be?
Session Creation

### What phase of the session management lifecycle would be vulnerable if you don't have the ability to flush a threat actor's access to your session?
Session Termination

### What phase of the session management lifecycle would be vulnerable if there wasn't sufficient information to piece together what happened during an incident?
Session Tracking

### What phase of the session management lifecycle would be vulnerable if the session value itself was transmitted through an insecure redirect?
Session Creation

# Task 6 : Exploiting Insecure Session Managment
This main trick to solve this challenge is to edit the cookie value from "student" to "lecturer" and then visiting the website according the question.

### What is the username of the student with the name X?
THM{Got.the.User}

### How many lecturers are registered on the application?
1

### Excluding the unauthenticated user, how many roles does the application have?
3

### How many test attempts in total have been performed on the application?
4

### What is the highest score that student1 has achieved on a test?
3

### What is the sequence of correct answers for the Database Types test? (Format y=yes and n=no, separated by commas)
y,n,n

# Task 7 : Conclusion

Defences

To defend against these attacks, it is important to implement a secure session management lifecycle. While several items were touched on in this room, let's take a look at a recap:

- The session's values must be stored securely, regardless of being a cookie or a token.
- The session values themselves must be either sufficiently random and non-guessable or use a signing mechanism to ensure that they cannot be tampered with.
- Sessions should be used to track user actions and perform authorisation checks to ensure the user can perform the requested action.
- Sessions should expire after a set amount of time to prevent them from being used for persistent access.
- If the logout button is pressed, the session should be removed client-side and invalidated server-side. Otherwise, a user would be unable to destroy their session if it was compromised.